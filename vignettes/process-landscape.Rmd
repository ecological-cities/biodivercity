---
title: "Process Landscape Data"
subtitle: "Download and process OpenStreetMap and satellite data"
author: "Edwin Tan"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Process Landscape Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This article details various ways to download and process publicly available landscape data to build predictive models of animal diversity. Here, landscape data refers to data derived from both open-source maps and freely-available satellite data. The following outline includes methods to download, process and summarise the landscape data for a specified date range and spatial areas.

First, load the necessary packages to run the analysis:

```{r load required libraries, message = FALSE, warning = FALSE, eval = FALSE}
library("biodivercity")
library("dplyr") # to process/wrangle data
library("sf") # to process vector data
library("tmap") # for visualisation
```

```{r load biodivercity while in dev, include = FALSE}
devtools::load_all()
library("sf")
library("dplyr")
library("tmap")
```

The Punggol (`PG`) area (town) from the example data `sampling_areas` will be used to demonstrate the steps in this article, shown in the interactive map below.

```{r plot punggol area, warning = FALSE, message = FALSE, fig.height = 1.0, dpi = 300, out.width="50%"}

data(sampling_areas)

sampling_areas <- sampling_areas %>%
   filter(area == "PG")

tmap_mode("view")
tm_basemap(c("CartoDB.Positron")) +
  tm_shape(sampling_areas) + tm_borders(lwd = 2.0)
```
<br>

Finally, since this analysis involves the downloading of datasets, define an output directory for raw and processed data to be exported to:

```{r define output directories, warning = FALSE, message = FALSE, eval = FALSE}
output_dir <- "</FILEPATH/TO/DIRECTORY>"
```

<br>

## OpenStreetMap (OSM) data

Built elements of the landscape can be retrieved from the OpenStreetMap (OSM) database. Building polygons and road lines will be extracted from `sampling_areas` using the functions `get_buildings_osm()` and `get_roads_osm()` respectively. The `date` argument, if specified, must be a snapshot date present within the [Geofabrik database](https://download.geofabrik.de). If not, the latest data will be downloaded. In this example, we download these urban elements for the date 1 Jan 2021 and visualise them below:

```{r download urban elements, eval = FALSE}

dir.create(paste0(output_dir, "/osm")) # create sub-directory

buildings <- get_buildings_osm(place = sampling_areas,
                               date = as.Date("2021-01-01"),
                               dir_raw = paste0(output_dir, "/osm"))

roads <- get_roads_osm(sampling_areas,
                       date = as.Date("2021-01-01"),
                       dir_raw = paste0(output_dir, "/osm"))

tmap_mode("view")
tm_basemap(c("CartoDB.Positron")) +
  tm_shape(sampling_areas) + tm_borders() +
  tm_shape(buildings) + tm_polygons(col = "levels") +
  tm_shape(roads) + tm_lines(col = "lanes", palette = "YlOrRd")
```

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.width=2.6, fig.height = 2.0, dpi = 300, out.width="100%"}

filepath <- system.file("extdata", "osm_data.Rdata", package = "biodivercity")
load(filepath)

tmap_mode("view")
tm_basemap(c("CartoDB.Positron")) +
  tm_shape(sampling_areas) + tm_borders() +
  tm_shape(buildings) + tm_polygons(col = "levels") +
  tm_shape(roads) + tm_lines(col = "lanes", palette = "YlOrRd")
```

<br>

We can summarise various metrics for the downloaded datasets, at specific point locations and buffer radii. In this example, we randomly generate three points within the `sampling_areas`.

```{r}
set.seed(123)

points <- st_sample(sampling_areas, 3) %>% 
  st_as_sf() %>% 
  mutate(point_id = row.names(.)) # unique identifier
```

The following list are possible metrics that may be summarised from the OSM data that were downloaded:

- Buildings (polygons) each with the number of levels
    - Floor area ratio (`buildingFA_ratio`)    
    - Average number of levels (`buildingAvgLvl`)

- Roads (lines) each with the number of lanes 
    - Lane density (`laneDensity`)
    
<br>

The function `osm_perpoint_specified()` can be be used to generate the summaries. To do so, we need to supply a character vector of predictor names to the function argument `predictors_osm`. The naming format is `r<value>m_osm_<metric>`; the prefix `r<value>m` denotes the buffer radius that the particular landscape data was summarised within, and `_osm_` denotes that the variables were generated from OpenStreetMap data. For example, we can summarise the building floor area ratio at a radius of 50 m and 100 m around `points`â€“these variables are appended as new columns.

```{r osm_perpoint, warning = FALSE, message = FALSE}

predictors <- c("r50m_osm_buildingFA_ratio", "r100m_osm_buildingFA_ratio") # variables to summarise

points_output <- osm_perpoint_specified(vector_osm = buildings,
                                        building_levels = "levels",
                                        predictors_osm = predictors,
                                        points = points)

points_output
```

<br>

---

## Sentinel-2 satellite data

Land cover information can be derived from publicly available Sentinel-2 data, downloadable via the package [`sen2r`](http://sen2r.ranghetti.info/index.html). Numerous parameters can be defined, both programmatically and via a graphical user interface as follows. Refer to the website for more information on its [installation and use](http://sen2r.ranghetti.info/articles/installation.html).

```{r sen2r gui, eval = FALSE}
library(sen2r)
sen2r()
```


```{r out.width = "100%", fig.align='center', dpi = 300, echo = FALSE, fig.cap = "**Figure: A screenshot of the `sen2r` graphical user interface accessible by running `sen2r::sen2r()`.**"}
knitr::include_graphics("sen2r-gui.png", dpi = 300)
```

<br>

The same parameters can be defined as arguments within `sen2r()`, or loaded from a JSON file. In this example, we download raw data from 1 Jan to 30 Jun 2021, with not more than 15% cloud cover within `sampling_areas`. For each image, the spectral indices [`NDVI`](https://www.indexdatabase.de/db/i-single.php?id=58) and [`NDWI2`](https://www.indexdatabase.de/db/i-single.php?id=546) will also be processed; these will be used to map vegetation and water cover, respectively. Do note that you will need to enter your account credentials with the [ESA Sentinel Hub](https://scihub.copernicus.eu/dhus/#/home). Detailed steps and the use of other servers (e.g. Google Cloud) can be found on the [package website](http://sen2r.ranghetti.info/index.html).

```{r sen2r, eval = FALSE}

# create sub-directories
dir.create(paste0(output_dir, "/sen2r")) 
dir.create(paste0(output_dir, "/sen2r/raw"))

out_paths <- sen2r(
  param_list = sen2r_params,
  timewindow = as.Date(c("2021-01-01", "2021-06-30")),
  max_cloud_safe = 15, # max 15% cloud cover in raw tile
  max_mask = 15, # max 15% cloud cover over sampling_areas
  extent = geojsonsf::sf_geojson(sampling_areas) # needs geojson as input
  extent_as_mask = TRUE, # pixel values outside are set to NA
  clip_on_extent = TRUE,
  list_indices = c("NDVI", "NDWI2") # to map vegetation and water
  list_rgb = "RGB432B", # output an RGB image as well
  path_l2a = paste0(output_dir, "/sen2r/raw"), 
  path_l1c = paste0(output_dir, "/sen2r/raw"),
  path_out = paste0(output_dir, "/sen2r"),
  path_indices = paste0(output_dir, "/sen2r"))
```

<br>

Raster files downloaded across multiple dates can be combined to create mosaics to account for cloud cover. Using the `mosaic_sen2r()` function, this can be easily done with the file directory created by `sen2r()`, as specified in the `path_out` argument.

```{r mosaic generation, eval = FALSE}
mosaic_sen2r(parent_dir = paste0(output_dir, "/sen2r"),
              exclude = NULL,
              rm_outlier = TRUE)
```

Downloaded rasters and the resulting mosaics contain raw information for specified indices. To account for noise and classify pixel values, Otsu's thresholding (see `threshold_otsu()`) can be used to define threshold values, where values above the threshold are regarded as a presence of the landscape type measured by an index. Here, we are classifying values above the threshold as "Present" with the value of `1` and values below the threshold as "Absent" with `0`.

```{r mosaic classification, warning = FALSE, message = FALSE}
ndvi_mosaic <- system.file("extdata", "ndvi_mosaic.tif", package="biodivercity") %>% 
  terra::rast()

veg_classified <- classify_image_binary(image = ndvi_mosaic,
                      threshold = "otsu")
```

To visualise the raster, several packages such as `ggplot2`, `tmap`, and `raster` can be used. Here, `tmap` is used to briefly examine the raster after classification.

```{r visualise raster, warning = FALSE, message = FALSE, fig.width=2.6, fig.height = 2.0, dpi = 300, out.width="100%"}
library("tmap")

tmap_mode("view")
tm_shape(veg_classified) +
  tm_raster(title = "veg_classified",
            style = "cat",
            palette = c("grey", "darkgreen"))
```

With the classified mosaics, landscape metrics can then be extracted at the defined buffer distances around fauna sampling points. The sample dataset `data(sampling_points)` can be loaded for survey points at which landscape metrics from the classified mosaic `veg_classified` will be summarised to. In this example, `sampling_points` is subset to match the same spatial area of the mosaic. 

```{r lsm_perpoint data, eval = FALSE}
data(sampling_points)
sampling_points <- sampling_points %>% 
  dplyr::filter(area == "PG")
```

Next, several arguments have to be defined for the `lsm_perpoint()` function and more information on the input formats can be found on the function page. For example, `buffer_sizes` refer to the buffer radius values (in meters) around the sampling point where the raster data is summarised from.

```{r lsm_perpoint, eval = FALSE}
veg_landscape_metrics <- lsm_perpoint(raster = veg_classified,
                                      points = sampling_points,
                                      buffer_sizes = c(50, 100),
                                      class_names = c("veg"),
                                      class_values = c(1),
                                      landscape_name = "veg",
                                      level = c("class")) 
```

Alternatively, certain desired landscape metrics can be specified for calculation via the `lsm_perpoint_specified()` function instead of summarising the full suite of metrics. For example, to calculate the `pland` metric for the classified vegetation mosaic at multiple buffer distances (50m, 100m), the metrics must first be defined:

```{r lsm_perpoint_specified data, warning = FALSE, messages = FALSE}
predictors_lsm <- vector()
dist <- c(50, 100)

raster_list <- list()
raster_list[[1]] <- veg_classified

for(i in seq_along(dist)){
  predictors_lsm[i] <- paste0("r", dist[i], "m_lsm_veg_pland")
}

predictors_lsm
```

The function can then be run without the need for providing buffer sizes:

```{r lsm_perpoint_specified, eval = FALSE}
pland <- lsm_perpoint_specified(raster_list = raster_list,
                                predictors_lsm = predictors_lsm,
                                class_names = c("veg"),
                                class_values =  c(1),
                                points = sampling_points,
                                point_id = "point_id",
                                period = "period"
                                )
```

