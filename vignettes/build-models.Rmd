---
title: "Build Models"
subtitle: "Train models that predict animal diversity from landscape data"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Build Models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This article outlines a workflow to build predictive models of diversity for a chosen animal group. Fauna and landscape data should have already been prepared based on `vignette("process-animal")` and `vignette("process-landscape")`, respectively. Based on community ecology theory, we ‘decompose’ animal diversity into two components: (1) local (_Alpha_) diversity and (2) community (_Beta_) diversity. A predictive model will be built for each component.

<br>

```{r out.width = "70%", fig.align='center', dpi = 300, echo = FALSE}
knitr::include_graphics("framework_build-models.png", dpi = 300)
```
<center><b> Figure: Broad overview of the data workflow for a chosen animal group </b></center>

<br>

First, load the necessary packages used throughout this article:

```{r eval = FALSE}
library("biodivercity")
library("tidyverse") # to process/wrangle data
library("sf") # to process landscape data
```

```{r load biodivercity while in dev, include = FALSE}
devtools::load_all()
library("tidyverse") 
library("sf") 
```
 
<br>

---

## 1. Local (_Alpha_) diversity

For a chosen animal group, local (_Alpha_) diversity is represented by the number of species recorded at sampling point locations (i.e., species density). The response variable is the number (count) of species. Generalised linear mixed-effects models (GLMMs) can be used to model count data, and linear models are generally simpler and provide better interpretability. Do note that other types of models/algorithms can also be used to model count data. Also, the full list of potential predictor variables may first be narrowed down; for example, random forest models may be used to select variables based on their relative importance in improving model performance (Arthur et al., 2010; Li et al., 2017). 

Load the necessary packages to model local (_Alpha_) diversity:

```{r message = FALSE, warning = FALSE}
library("lme4") # mixed-effects modelling
library("MuMIn") # model selection & averaging
```

Load the example datasets for birds (animal group 'Aves') recorded at sampling points across Singapore. `birds` is a dataframe containing the number of species aggregated across multiple surveys (i.e., species richness; column '`sprich`'), and `landscape` is a dataframe containing landscape predictors summarised within specified buffer radii. These example datasets can be obtained by following the steps in `vignette(process-animal)` and `vignette(process-landscape)`, respectively. See `data(animal_surveys)` and `data(points_landscape)` for further details about the underlying animal and landscape data.

```{r load example data}
filepath <- system.file("extdata", "build-models_alpha-diversity.Rdata", package="biodivercity")
load(filepath)
```

Pivot the `landscape_data` to wide format, with the prefix `r<radius>m_` (representing the radius size) appended to the column names of predictors:

```{r transform and combine data - alpha, message = FALSE}
landscape <- landscape %>% 
  pivot_longer(cols = c(starts_with("osm_"), starts_with("lsm_")),
               names_to = 'metric') %>% 
  pivot_wider(id_cols = c("town", "point_id"),
              names_from = c("radius_m", "metric"), 
              values_from = "value",
              names_glue = "r{radius_m}m_{metric}")

# combine bird and landscape data, then then scale/center variables
birds <- birds %>% 
  inner_join(landscape, by = c("town", "point_id")) 
birds_scaled <- birds %>% 
  mutate(across(.cols = where(is.numeric) & !sprich, scale))

head(birds_scaled) # view combined data
```

To fit the model as a GLMM, the function `MuMIn::dredge()` will be used. The function includes customisation options; for instance, the `subset` argument allows the user to exclude certain combinations of variables within the fitted model (i.e., apply constraints to possible models that may be built). In the following example, we do not allow the same landscape predictor summarised within multiple buffer radii to be present in the same model.

```{r create object to be supplied to function argument}

predictors <- grep("^r[0-9]+m_",  colnames(birds_scaled), value = TRUE) # get predictor names

# get rows with same predictors but different radii
var_comb <- combn(predictors, 2) %>% # unique combinations
  t() %>% 
  as.data.frame() %>%  # separate radii & predictors
  separate(V1, c("V1_radius", "V1_predictor"),
           sep = "(?<=[0-9])m_(?=[A-Za-z]*)", remove = FALSE) %>% 
  separate(V2, c("V2_radius", "V2_predictor"),
           sep = "(?<=[0-9])m_(?=[A-Za-z]*)", remove = FALSE) %>%
  rowwise() %>% 
  mutate(similar = grepl(V1_predictor, V2_predictor)) %>% 
  filter(isTRUE(similar))

# create object to be supplied to function argument
subset_vect <- paste(var_comb$V1, "&", var_comb$V2)
subset_exp <- parse(text = paste0("!(", paste(subset_vect, collapse = ") & !("), ")")) # function argument requires an expression

```

```{r include = FALSE}
rm(filepath, landscape,
   var_comb, subset_vect)
```

Next, we fit both a global (maximal) model and null model, in order to calculate the difference in Akaike Information Criterion (AIC) value within the function `MuMIn::dredge()`. In the example data, the '`town`' is specified as the random effect. The argument '`family`' is specified as `"poisson"`, since the response variable is count data. See the function `lme4::glmer()` for more details and information on its arguments.

```{r global and null model}
model_global <- 
  glmer(paste("sprich", "~", paste(predictors, collapse = " + "), 
              "+ (1|town) "),
        family = "poisson",
        na.action = "na.fail",
        control = lme4::glmerControl(optimizer = "bobyqa"),
        data = birds_scaled)

model_null <- 
  glmer(sprich ~ 1 + (1|town), family = "poisson", data = birds_scaled)
```

Automated model selection is performed using the function `MuMIn::dredge()`. Models are ranked based on their `AICc` value (AIC adjusted for small sample sizes). Model constraints are specified in the argument `subset`. To avoid a long runtime in this demonstration, we also limit the number of predictor variables in each model to four (argument `m.lim`).

```{r example dredge - dredge, message = FALSE, warning = FALSE}
model_glm <- dredge(model_global,
                    subset= subset_exp,
                    m.lim=c(NA,4), # max of 4 variables
                    rank="AICc")
```

The resulting object contains a model selection table, with each row representing a model that was fit. It is arranged in ascending order, based on AIC value (lower AIC value represents a 'better' model). A summary of the top models with values of ΔAIC < 2 can be viewed:

```{r table of best models}
bestmodels_info <- subset(model_glm, 
                         delta < 2, 
                         recalc.weights=FALSE)

knitr::kable(bestmodels_info, caption = "**Summary of best models ranked based on automated model selection from `MuMIn::dredge()` (ΔAIC < 2).**") %>%
  kableExtra::kable_styling("striped") %>% kableExtra::scroll_box(width = "100%", height = "300px")
```
We can also visualise the importance (based on sum-of-weights) and effect direction (based on coefficient value) for each variable within the top models:

```{r plot important variables, message = FALSE, dpi = 300, fig.width=5, fig.height=4, fig.align='center', out.width="70%"}

# average the effect of each predictor
effects <- data.frame(coef(bestmodels_info)[,-1]) %>% 
  summarise(across(everything(), ~ mean(.x, na.rm = TRUE))) %>% 
  pivot_longer(everything(), names_to = "var") %>% 
  mutate(effect = ifelse(value > 0, "Positive", "Negative"))

# get importance of each predictor
importances <- data.frame(MuMIn::sw(bestmodels_info)) %>% 
  rename(imp = MuMIn..sw.bestmodels_info.) %>% 
  rownames_to_column("var") %>% 
  left_join(effects, by = "var") %>% # join with effects
  mutate(effect = ifelse(is.na(effect), "Mixed (factor)", effect)) %>%
  mutate(effect = factor(effect, levels = c("Positive", "Negative", "Mixed (factor)")))

# plot
ggplot(data=importances, aes(x = imp, y = reorder(var, imp), 
                     fill = effect)) + 
  geom_bar(stat = "identity") +
  labs(x = "Sum of weights", y = "Variables") +
  scale_fill_manual(values = c("#4daf4a", "#e41a1c", "#377eb8"),
                    name = "Effect")

```

Finally, we can extract the models and `recipes::recipe()` objects for future use:

```{r}

# get list of best models
bestmodels <- MuMIn::get.models(bestmodels_info, subset = TRUE)

# create recipes object only with predictors within best models
predictors_best <- colnames(coef(bestmodels_info)[,-1])

birds <- birds %>% # original unscaled dataset
  dplyr::select(sprich, town, all_of(predictors_best)) # remove unnecessary columns

recipe_birds <- recipes::recipe(birds) %>% 
  recipes::update_role(sprich, new_role = "outcome") %>%
  recipes::update_role(town, new_role = "id") %>%
  recipes::update_role_requirements("id", bake = FALSE) %>%
  recipes::step_normalize(all_of(predictors_best)) %>% 
  recipes::prep()
```


```{r, include = FALSE}
rm(birds, birds_scaled, predictors, subset_exp,
   model_glm, model_global, model_null, 
   effects, importances,
   bestmodels, bestmodels_info, predictors_best, recipe_birds)
```

<br>

---

## 2. Community (_Beta_) diversity

To be released.

<br>

---

## References

Arthur AD, Li J, Henry S & Cunningham SA (2010) Influence of woody vegetation on pollinator densities in oilseed Brassica fields in an Australian temperate landscape. _Basic and Applied Ecology_, _11_(5): 406–414.

Li J, Alvarez B, Siwabessy J, Tran M, Huang Z, Przeslawski R, Radke L, Howard F & Nichol S (2017) Application of random forest and generalised linear model and their hybrid methods with geostatistical techniques to count data: Predicting sponge species richness. _Environmental Modelling and Software_, _97_: 112–129.
