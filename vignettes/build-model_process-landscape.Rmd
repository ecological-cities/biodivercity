---
title: "Get and process landscape metrics"
author: "Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
navbar: ~
vignette: >
  %\VignetteIndexEntry{Get and process landscape metrics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview
**Sections that require attention are marked with <u>ATTN</u>**

1. Sentinel-2 data is first downloaded from the free and open-access Copernicus Open Access Hub via the package `sen2r`.
2. Images are mosaiced with the `insert-mosaic-function-here` function from this package.
3. Otsu thresholding is performed with the `threshold_otsu` function from this package.
4. `lsm_perpoint` function summarises landscape metrics for provided geographical points at specified buffers.
5. `get_roads_osm` and `get_buildings_osm` (`home2park` package is a dependency)

Necessary input as sample dataset:
- Sentinel-2 mosaic raster with NDVI and NDWI2
- Sampling points geojson
- Sampling area (e.g. town) boundaries geojson

## Using sen2r to get images (optional?)

Images were downloaded with `sen2r`, it can be installed from [CRAN](https://cran.r-project.org/package=sen2r).

```{r sen2r setup, eval = FALSE}
# http://sen2r.ranghetti.info/articles/installation.html
install.packages("sen2r")

# install Sen2Cor software (atmospheric correction for Level-1C products)
library(sen2r)
check_sen2r_deps() # check dependencies
install_sen2cor(force = TRUE) # install via command instead of GUI
```

Using `sen2r`:
- Check their vignette

Desired indices: **NDVI**, **NDWI2**

## Processing mosaics of downloaded images

**NOTE**: This parallel-processed mosaic generation can be a new function? 
**ATTN**: would be difficult to include as sample since file sizes are large

```{r mosaic generation, eval = FALSE}
directories <- list.dirs(glue::glue("{dir_dataoutput}/processed/{which_round}"), recursive = FALSE)
directories <- directories[!basename(directories) %in% c("CLD", "SCL", "RGB432B")] # rm directories not to be mosaiced

# loop to process/export mosaic for each subdirectory
# Note: doesn't make sense for SCL (surface classification map), CLD (cloud mask) & RGB432B (RGB, clouds are white not NA) 
foreach(i = 1:length(directories), # parallel loop
                   .packages = c("terra", "raster")) %dopar% { # foreach loops
  
  # for each spectral index, import images as rasterStack
  filepaths <- dir(path = directories[i], full.names = TRUE, pattern="*.tif$")
  filepaths <- filepaths[!grepl("mosaic", filepaths)] # exclude previously generated/processed mosaics
  
  images <- lapply(filepaths, rast) # import as list
  
  # don't run these for non-spectral indices
  if(!grepl(c("BOA"), directories[i])){
    images <- lapply(images, function(x) x/10000) # re-scale
  }
  
  # remove outliers (for specific spectral indices)
  if(basename(directories[i]) %in% c("NDVI", "NDWI2")){
    
    for(j in 1:length(images)){
        images[[j]][images[[j]] < -1] <- NA
        images[[j]][images[[j]] > 1] <- NA
    }
  }
  
  # MOSAIC IMAGES
  if(basename(directories[i]) %in% c("BOA")){ # if multiband, use raster::mosaic (weird error if use terra::mosaic)
    
    images <- lapply(filepaths, raster::stack) # import as list, overwrite var
    images$fun <- mean
    images$na.rm <- TRUE
    mosaic <- do.call(raster::mosaic, images)
    
    raster::writeRaster(mosaic, 
                paste0(directories[i], "/mosaic.tif"),
                overwrite = TRUE)
    
    
  }else{ # single band spectral index mosaics
  
    mosaic <- do.call(terra::mosaic, c(images, 
                                       list(fun = "mean"))) 
    writeRaster(mosaic, 
                paste0(directories[i], "/mosaic.tif"),
                  wopt = list(gdal=c("COMPRESS=LZW")),
                  overwrite = TRUE)
  }
  
  cat(paste0(Sys.time(), " Exported mosaic for: "), filepaths, 
      sep = "\n", 
      file=paste0("parallel-processing-log.txt"), append=TRUE)
  
  
  rm(mosaic, images, filepaths, i, j)
  gc()
}
```

## Otsu's thresholding for mosaicked images

To make sense of the raster data, the important information (e.g. landscape metrics) has to be isolated from the noise. Otsu's thresholding ([Otsu, 1979](https://cw.fel.cvut.cz/wiki/_media/courses/a6m33bio/otsu.pdf)) is an automated threshold finder that outperforms other techniques in terms of stability of results and processing speed, even with the presence of >2 peaks in the histogram ([Bouhennache et al., 2019](https://www.tandfonline.com/doi/abs/10.1080/10106049.2018.1497094)). The NDVI threshold for vegetation typically ranges from 0.2 to 0.4 ([Wong et al, 2019](https://link.springer.com/article/10.1186/s40562-019-0132-4); [Akbar et al, 2019](https://www.mdpi.com/2072-4292/11/2/105)). A second thresholding is performed for the vegetation class to separate sparse from dense vegetation.

```{r otsu thresholding, eval = FALSE}
files <- paste0(dir, rounds,  "/NDVI/mosaic.tif")

# get threshold value via otsu method (assumes bimodal histogram)
thresholds <- list()
for(i in 1:length(rounds)){
  thresholds[[i]] <- threshold_otsu(files[i], levels = 256) #default levels = 256 for 8-bit images
  rm(i)
}

# apply first threshold & get sub-classification threshold
thresholds2 <- list()
for(i in 1:length(files)){
  
  raster <- rast(files[i])
  raster[raster < thresholds[[i]]] <- NA # mask away those below threshold value
  
  # second thresholding
  thresholds2[[i]] <- threshold_otsu(raster, levels = 256)
  rm(raster, i)
}

# view thresholds
thresholds[[1]]
#[value 1]
thresholds[[2]]
#[value 2]
```

![**Distribution of NDVI values across Singapore in Survey Round One (light green bars, dashed vertical lines) and Two (dark green bars, solid vertical lines).** Based on image mosaic composed of data captured for Survey Round One and Survey Round Two. Vegetation was classified as pixel with values >0.35 for Round One and >0.36 for Round Two, via Otsu's thresholding. Dense vegetation was classified as pixels with values >0.62 for Round One and >0.64 for Round Two, using the same method after the first round of classification.](./images/otsu-sample-plot.png){#id .class width=60% height=60%}

## Summarising mosaic landscape metrics within buffer distance of a point

To build a model with point survey data, landscape metrics have to be isolated from a buffer distance around fauna sampling points. The `lsm_perpoint` function accepts a geographical input of sampling points and extracts surrounding landscape metrics from the processed mosaic into an output dataframe. Mosaicked rasters should be processed to classify respective land cover types as discrete values (e.g. vegetation classes may be classified `0` for non-vegetation; `1` for sparse; `2` for dense).

```{r load sampling points w landcover data, eval = FALSE}
points <- st_read(glue::glue("{dir_dataoutput}/sampling/points.geojson"), quiet = TRUE) 

circles_sf <- list()
for(i in 1:length(params$sen2r_points_buffers)){
  
  circles_sf[[i]] <- st_buffer(points, 
                            dist = params$sen2r_points_buffers[i], # buffer distance
                            nQuadSegs = 30) # line segments per quadrant
  
  # circles_sf[[i]]$area_m2 <- st_area(circles_sf[[i]]) # calc area
  
  names(circles_sf)[i] <- params$sen2r_points_buffers[i]
  
  rm(i)
}

```

**ATTN**: urban_classified no longer relevant as NVBI is not used?

```{r append landcover-related data to sampling points - use sample_lsm, eval = FALSE}

circles <- lsm_perpoint(raster = veg_classified, points = points, 
                        buffer_sizes = params$sen2r_points_buffers,
                        class_names = c("vegSparse", "vegDense"),
                        class_values = c(1, 2),
                        landscape_name = "veg",
                        level = c("class", "landscape")) 

for(i in 1:length(circles)){ # append to circles2 info to circles
  circles[[i]] <- circles[[i]] %>%
    mutate(across(.cols = starts_with("lsm_"), # make NA if percentage_inside < 90
                  ~ifelse(percentage_inside < 90, NA, .))) %>%
    dplyr::select(-percentage_inside)
}
cat(paste0(Sys.time(), " Veg cover: Processed for sampling points\n"), 
          file=paste0("parallel-processing-log.txt"), append=TRUE)



# circles2 <- lsm_perpoint(raster = urban_classified, points = points, 
#                         buffer_sizes = params$sen2r_points_buffers,
#                         class_names = c("urban"),
#                         class_values = c(1),
#                         landscape_name = "urban",
#                         level = c("class", "landscape"))
# cat(paste0(Sys.time(), " Urban cover: Processed for sampling points\n"), 
#           file=paste0("parallel-processing-log.txt"), append=TRUE)
# 
# for(i in 1:length(circles)){ # append to circles2 info to circles
#   circles[[i]] <- circles[[i]] %>%
#     full_join(circles2[[i]] %>% 
#                  mutate(across(.cols = starts_with("lsm_"), 
#                   ~ifelse(percentage_inside < 90, NA, .))) %>%
#                 dplyr::select(-percentage_inside), 
#               by = c("point_id", "round"))
# }
# rm(circles2, i)



circles2 <- lsm_perpoint(raster = water_classified, points = points, 
                        buffer_sizes = params$sen2r_points_buffers,
                        class_names = c("water"),
                        class_values = c(1),
                        landscape_name = "water",
                        level = c("class", "landscape")) 
cat(paste0(Sys.time(), " Water cover: Processed for sampling points\n"), 
          file=paste0("parallel-processing-log.txt"), append=TRUE)

for(i in 1:length(circles)){ # append to circles2 info to circles
  circles[[i]] <- circles[[i]] %>%
    full_join(circles2[[i]] %>% 
                 mutate(across(.cols = starts_with("lsm_"), 
                  ~ifelse(percentage_inside < 90, NA, .))) %>%
                dplyr::select(-percentage_inside), 
              by = c("point_id", "round"))
}

# combine geometry of circles_sf with circles
for(i in 1:length(circles)){
  circles[[i]] <- circles_sf[[i]] %>%
    full_join(circles[[i]] %>%
                mutate(round = as.numeric(round)))
  rm(i)
}
```

## Retrieving OSM data on urban metrics

Urban landscape elements are retrieved from the freely-available OpenStreetMap (OSM) database. In the Sentinel-2 images, buildings would be represented by their building footprint as opposed to three-dimensional structures. The number of above-ground levels from OSM can act as a proxy for building height, especially in the residential buildings of Singapore where the floor-to-floor height is standardised, and complements the two-dimensional footprint. (Building height data may also be supplied by government databases if available (e.g. [HDB Property Information from data.gov.sg](https://data.gov.sg/dataset/hdb-property-information)), otherwise OSM can be a great "universal" source.) 

In this example, the building polygons and road lines are extracted from a set geographical boundary with the functions `get_buildings_osm` and `get_roads_osm`. `home2park`, a GitHub package, and `osmextract` are required dependencies for these functions and this package. Building `levels` was derived from `building:levels`; values were set to `1` if the extracted value was empty or `NA`, and set to `NA` if ≤ 0 (i.e. underground); values were then rounded up to the nearest whole number. 

```{r download urban elements w parallel loops, eval = FALSE}
osm_boundaries <- st_read("<geo-boundaries>.geojson", quiet = TRUE) %>% # ATTN: come back with sample dataset
  # st_union() %>% # merge all subzones
  st_as_sf() %>%
  st_make_valid()

# get_roads_osm is not in home2park package. Need to load dependency libraries

foreach(i = seq_along(params$osm_download_dates), 
                   .packages = c("home2park",
                                 "tidyverse", "sf", "osmextract")) %dopar% { 
  
  # buildings                   
  get_buildings_osm(osm_boundaries, 
                    date = params$osm_download_dates[i],
                    dir_raw = params$osm_dir_rawdata,
                    filename = paste0(dir_dataoutput, "/landscape/osm/buildings_osm-polygons_", params$osm_download_dates[i], ".geojson"))
              
  # roads
  get_roads_osm(osm_boundaries, 
                date = params$osm_download_dates[i],
                dir_raw = params$osm_dir_rawdata,
                filename = paste0(dir_dataoutput, "/landscape/osm/roads_osm-lines_", params$osm_download_dates[i], ".geojson"))       
                     
  rm(i)                   
}
```
