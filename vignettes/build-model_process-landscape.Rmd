---
title: "Get and process landscape metrics"
author: "Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
navbar: ~
vignette: >
  %\VignetteIndexEntry{Get and process landscape metrics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview
**Sections that require attention are marked with <u>ATTN</u>**

1. Sentinel-2 data is first downloaded from the free and open-access Copernicus Open Access Hub via the package `sen2r`.
2. Images are mosaicked with the `mosaic_sen2r` function from this package for spectral indices.
3. Otsu thresholding is performed with the `threshold_otsu` function and then classified with `classify_mosaic`.
4. `lsm_perpoint` function summarises landscape metrics for provided geographical points at specified buffers.
5. `get_roads_osm` and `get_buildings_osm` functions are used to retrieve further urban landscape data from OpenStreetMap.

Necessary input as sample dataset:
- Sentinel-2 mosaic raster with NDVI and NDWI2
- Sampling points geojson
- Sampling area (e.g. town) boundaries geojson

## Using sen2r to get images

Images were downloaded with `sen2r`, it can be installed from [CRAN](https://cran.r-project.org/package=sen2r).

```{r sen2r setup, eval = FALSE}
# http://sen2r.ranghetti.info/articles/installation.html
install.packages("sen2r")

# install Sen2Cor software (atmospheric correction for Level-1C products)
library(sen2r)
check_sen2r_deps() # check dependencies
install_sen2cor(force = TRUE) # install via command instead of GUI

out_dir  <- glue::glue("{dir_dataoutput}/spatial/satellite-images/sen2r/sen2r_", {as.character(params$sen2r_date_range[1])}, "-to-", {as.character(params$sen2r_date_range[2])})

# run this after every successful download if there are still files in LTA not yet online, then subsequently check with provided safe_is_online() and sen2r():
out_paths <- sen2r(
  param_list = params$sen2r_params,
  timewindow = c(as.Date(params$sen2r_date_range[1]), as.Date(params$sen2r_date_range[2])),
  path_l2a = params$sen2r_dir_rawdata, # level-2A SAFE products
  path_l1c = params$sen2r_dir_rawdata, # level-1C SAFE products
  path_out = out_dir,
  path_indices = out_dir,
  extent_as_mask = TRUE,
  list_rgb = "RGB432B" # output RGB image
  # max_mask = 15,
  # list_indices = c("NDVI", "ARI")
  )
```


## Creating mosaics of downloaded images

```{r mosaic generation, eval = FALSE}
 mosaic_sen2r(parent_dir = out_dir,
              exclude = NULL,
              rm_outlier = TRUE)
```

## Classfifying mosaics

```{r mosaic classification, eval = FALSE}
classify_mosaic(x = "out_dir/index/mosaic.tif",
                otsu = TRUE,
                output = "out_dir/classified/")
```

## Otsu's thresholding for mosaicked images

To make sense of the raster data, the important information (e.g. landscape metrics) has to be isolated from the noise. Otsu's thresholding ([Otsu, 1979](https://cw.fel.cvut.cz/wiki/_media/courses/a6m33bio/otsu.pdf)) is an automated threshold finder that outperforms other techniques in terms of stability of results and processing speed, even with the presence of >2 peaks in the histogram ([Bouhennache et al., 2019](https://www.tandfonline.com/doi/abs/10.1080/10106049.2018.1497094)). The NDVI threshold for vegetation typically ranges from 0.2 to 0.4 ([Wong et al, 2019](https://link.springer.com/article/10.1186/s40562-019-0132-4); [Akbar et al, 2019](https://www.mdpi.com/2072-4292/11/2/105)). A second thresholding is performed for the vegetation class to separate sparse from dense vegetation.

```{r otsu thresholding, eval = FALSE}
veg_classified <- data(mosaic)

# get threshold value via otsu method (assumes bimodal histogram)
threshold <- list()
for(i in 1:length(rounds)){
  thresholds[[i]] <- threshold_otsu(veg_classified[i], levels = 256) #default levels = 256 for 8-bit images
  rm(i)
}

# view thresholds
thresholds[[1]]
#[value 1]
```

![**Distribution of NDVI values across Singapore in Survey Round One (light green bars, dashed vertical lines) and Two (dark green bars, solid vertical lines).** Based on image mosaic composed of data captured for Survey Round One and Survey Round Two. Vegetation was classified as pixel with values >0.35 for Round One and >0.36 for Round Two, via Otsu's thresholding. Dense vegetation was classified as pixels with values >0.62 for Round One and >0.64 for Round Two, using the same method after the first round of classification.](./images/otsu-sample-plot.png){#id .class width=60% height=60%}

## Summarising mosaic landscape metrics within buffer distance of a point

To build a model with point survey data, landscape metrics have to be isolated from a buffer distance around fauna sampling points. The `lsm_perpoint` function accepts a geographical input of sampling points and extracts surrounding landscape metrics from the processed mosaic into an output dataframe. Mosaicked rasters should be processed to classify respective land cover types as discrete values (e.g. vegetation classes may be classified `0` for non-vegetation; `1` for sparse; `2` for dense).

```{r lsm_perpoint, eval = FALSE}
points <- data(survey-points)
veg_classified <- data(mosaic)

circles <- lsm_perpoint(raster = veg_classified, points = points, 
                        buffer_sizes = c(50, 100, 126, 200, 400, 600, 800, 1000),
                        class_names = c("vegSparse", "vegDense"),
                        class_values = c(1, 2),
                        landscape_name = "veg",
                        level = c("class", "landscape")) 
```

## Retrieving OSM data on urban metrics

Urban landscape elements are retrieved from the freely-available OpenStreetMap (OSM) database. In the Sentinel-2 images, buildings would be represented by their building footprint as opposed to three-dimensional structures. The number of above-ground levels from OSM can act as a proxy for building height, especially in the residential buildings of Singapore where the floor-to-floor height is standardised, and complements the two-dimensional footprint. (Building height data may also be supplied by government databases if available (e.g. [HDB Property Information from data.gov.sg](https://data.gov.sg/dataset/hdb-property-information)), otherwise OSM can be a great "universal" source.)     

In this example, the building polygons and road lines are extracted from a set geographical boundary with the functions `get_buildings_osm` and `get_roads_osm`. `home2park`, a GitHub package, and `osmextract` are required dependencies for these functions and this package. Building `levels` was derived from `building:levels`; values were set to `1` if the extracted value was empty or `NA`, and set to `NA` if â‰¤ 0 (i.e. underground); values were then rounded up to the nearest whole number. 

```{r download urban elements w parallel loops, eval = FALSE}
osm_boundaries <- data(boundaries) %>% 
  # st_union() %>% # merge all subzones
  st_as_sf() %>%
  st_make_valid()

# get_roads_osm is not in home2park package. Need to load dependency libraries

foreach(i = seq_along(params$osm_download_dates), 
                   .packages = c("home2park",
                                 "tidyverse", "sf", "osmextract")) %dopar% { 
  
  # buildings                   
  get_buildings_osm(osm_boundaries, 
                    date = params$osm_download_dates[i],
                    dir_raw = params$osm_dir_rawdata,
                    filename = paste0(dir_dataoutput, "/landscape/osm/buildings_osm-polygons_", params$osm_download_dates[i], ".geojson"))
              
  # roads
  get_roads_osm(osm_boundaries, 
                date = params$osm_download_dates[i],
                dir_raw = params$osm_dir_rawdata,
                filename = paste0(dir_dataoutput, "/landscape/osm/roads_osm-lines_", params$osm_download_dates[i], ".geojson"))       
                     
  rm(i)                   
}
```
