---
title: "Apply Models"
subtitle: "Generate spatial predictions across a landscape"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Apply Models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This article outlines the steps to predict the diversity of a particular animal group across a target landscape. The pixel-based predictions can then be visualised spatially as a raster image. Based on community ecology theory, we ‘decompose’ animal diversity into two components: (1) local (_Alpha_) diversity and (2) community (_Beta_) diversity. The example models built in `vignette("build-models")` will be used in this demonstration.

<br>

```{r out.width = "70%", fig.align='center', dpi = 300, echo = FALSE}
knitr::include_graphics("framework_apply-models.png", dpi = 300)
```
<center><b> Figure: Broad overview of the data workflow for a chosen animal group </b></center>

<br>

---

## 1. Local (_Alpha_) diversity

First, load the required packages:

```{r load required libraries, eval = FALSE, warning = FALSE, message = FALSE}
library("biodivercity")
library("dplyr") # to process/wrangle data
library("tmap") # for visualisation
```

```{r load libraries while in dev, include = FALSE}
devtools::load_all() 
library("dplyr") 
library("tmap")
```

In this article, we will make spatial predictions across the Punggol (`PG`) area in Singapore, taken from the example dataset `sampling_areas`.

```{r get ready example data for punggol, out.width="100%", message = FALSE, warning = FALSE}

# load polygon of punggol boundaries
data(sampling_areas)
punggol <- sampling_areas %>%
   filter(area == "PG")

# get landscape data ready
filepath <- system.file("extdata", "osm_data.Rdata", package = "biodivercity")
load(filepath)

ndvi_mosaic <- 
  system.file("extdata", "ndvi_mosaic.tif", package="biodivercity") %>% 
  terra::rast()
veg_classified <- classify_image_binary(ndvi_mosaic, threshold = "otsu")

# visualise 
tmap_mode("view")
tm_basemap(c("CartoDB.Positron")) +
  tm_shape(punggol) + tm_borders() +
  tm_shape(buildings_osm) + tm_polygons(col = "levels") +
  tm_shape(roads_osm) + tm_lines(col = "lanes", palette = "YlOrRd")+
  tm_shape(veg_classified) +
    tm_raster(style = "cat",
            palette = c("grey", "darkgreen"))
```

Next, load the model object and extract the landscape predictors within the best models. In this example, the largest radius for variables within the models is 400 metres.

```{r load alpha diversity model}
filepath <- system.file("extdata", "apply-models_alpha-diversity.Rdata", package="biodivercity")
load(filepath)

# landscape predictors
predictors <- colnames(coef(bestmodels_info)[,-1])
predictors

# get the max radius among all predictor variables
max_radius <- predictors %>% 
  stringr::str_extract("(?<=^r)\\d+") %>%  # extract buffer radii
  as.numeric() %>% 
  max(na.rm = TRUE)
max_radius
```


To make spatial predictions, the target area is broken up into many smaller points (pixels), where landscape data will be summarised and predictions will be made. First, use the function `generate_grid()` to generate a grid over the target area. 

```{r out.width = "70%", fig.align='center', dpi = 300, echo = FALSE, fig.cap = "Figure: Visualisation of the function `generate_grid()`."}
knitr::include_graphics("generate_grid.jpg", dpi = 300)
```

The pixel resolution of the grid can be customised with the argument `pixelsize_m`, which we specify as 100 metres in this example. An optional argument `innerbuffer_m` limits the spatial predictions to a smaller area within the target landscape. This is useful, for example, when the model requires broad-scale landscape data to make predictions, but available landscape data do not extend beyond the target area. Hence, to avoid inaccurate predictions that result from areas without landscape data, the distance value for this argument should correspond to the largest buffer radius present in the model variables. 

```{r generate grid for punggol}

grid_points <- generate_grid(target_areas = punggol, 
                             pixelsize_m = 100,
                             innerbuffer_m = max_radius) %>%
  rownames_to_column("point_id") # add unique identifier

grid_points # geometry column has been added
```

At each grid point, summarise the predictors for land cover and OpenStreetMap data using the functions `calc_specific_lsm()` and `calc_specific_osm()`, respectively. Each predictor will be summarised within the relevant distance buffer (radius) from the grid point, denoted by the prefix `r<value>m`. If manually generated landscape data were used and are present within the best models, the function `calc_manual()` can be used to summarise each landscape component; see `vignette("process-landscape")` for the full list of landscape vectors that may be summarised.

```{r message = FALSE, warning=FALSE}

# vegetation cover
predictors_veg <- stringr::str_subset(predictors, "lsm_veg_.*$")
results_veg <- 
  calc_specific_lsm(raster = veg_classified,
                    predictors_lsm = predictors_veg,
                    class_names = c("veg"),
                    class_values = c(1),
                    points = grid_points)

# osm buildings
predictors_buildings <- stringr::str_subset(predictors, "osm_building.*$")
results_buildings <-
      calc_specific_osm(vector = buildings_osm,
                        predictors_osm = predictors_buildings,
                        building_levels = "levels",
                        building_height = "height",
                        points = grid_points)

# osm roads
predictors_roads <- stringr::str_subset(predictors, "osm_lane.*$")
results_roads <-
      calc_specific_osm(vector = roads_osm,
                        predictors_osm = predictors_roads,
                        road_lanes = "lanes",
                        points = grid_points)

# combine results and overwrite 'grid_points' variable 
grid_points <- results_veg %>% 
  full_join(results_buildings %>% st_set_geometry(NULL)) %>% 
  full_join(results_roads %>% st_set_geometry(NULL))
grid_points
```

Finally, use the function `predict_heatmap()` to predict the number of bird species (species richness) across the grid of spatial points, based on the predictor variables summarised in `grid_points`. The model object(s) in `bestmodels` (`lme4::glmer()` objects) and `recipe_birds` (data pre-processing workflow `recipes::recipe()` object) will be used to make the predictions at each point. Ensure that the argument `pixelsize_m` is similar to the value used in `generate_grid()`.

```{r heatmap_raster}
bird_heatmap <- predict_heatmap(models = bestmodels, 
                                recipe_data = recipe_birds,
                                points_topredict = grid_points, 
                                pixelsize_m = 100)
```

The continuous raster may be visualised as a heat map:

```{r plot heatmap, message = FALSE, warning = FALSE, fig.width=2.6, fig.height = 2.0, dpi = 300, out.width="100%"}

tmap_options(max.raster = c(view = 1e8)) # increase max resolution to be visualised

tm_basemap(c("CartoDB.Positron", "OpenStreetMap")) +
  tm_shape(bird_heatmap, raster.downsample = FALSE) +
  tm_raster(title = "Number of bird species",
            style = "pretty",
            n = 8,
            palette = "YlOrRd",
            alpha = 0.6) 
  
```

```{r include = FALSE}
rm(filepath, max_radius,
   punggol, sampling_areas,
   ndvi_mosaic, veg_classified, buildings_osm, roads_osm,
   predictors, predictors_veg, predictors_buildings, predictors_roads,
   results_veg, results_buildings, results_roads, grid_points, 
   bestmodels, bestmodels_info, recipe_birds,
   bird_heatmap)
```


<br>

---

## 2. Community (_Beta_) diversity

To be released.

<br>

